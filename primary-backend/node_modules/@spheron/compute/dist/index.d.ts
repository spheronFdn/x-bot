import { MarketplaceCategoryEnum, ProviderEnum, InstanceStateEnum, Port, HealthStatusEnum, PersistentStorageClassEnum, ComputeTypeEnum, ClusterProtocolEnum, SpheronApi, ClusterFundsUsage, InstanceLogType } from '@spheron/core';
export { ClusterFundsUsage, ClusterProtocolEnum, ClusterStateEnum, InstanceLogType, InstanceStateEnum, MarketplaceAppPort, PersistentStorage, PersistentStorageClassEnum, ProviderEnum, UpdateInstaceRequest } from '@spheron/core';

interface Organization {
    id: string;
    profile: {
        name: string;
        username: string;
        image: string;
    };
}
interface MarketplaceApp {
    id: string;
    name: string;
    description: string;
    category: MarketplaceCategoryEnum;
    variables: MarketplaceAppVariable[];
}
interface MarketplaceAppVariable {
    defaultValue: string;
    key: string;
    required?: string;
}
interface ComputeMachine {
    id: string;
    name: string;
    cpu: number;
    storage: string;
    memory: string;
}
interface Cluster {
    id: string;
    name: string;
    url: string;
    proivder: ProviderEnum;
    createdBy: string;
    createdAt: Date;
    updatedAt: Date;
}
interface Instance {
    id: string;
    state: InstanceStateEnum;
    name: string;
    deployments: Array<string>;
    cluster: string;
    activeDeployment: string;
    agreedMachine: MachineImageType;
    healthCheck?: HealthCheck;
    createdAt: Date;
    updatedAt: Date;
}
interface InstanceDetailed extends Instance {
    cpu: number;
    memory: string;
    storage: string;
    image: string;
    tag: string;
}
interface HealthCheck {
    path: string;
    port?: Port;
    status?: HealthStatusEnum;
    timestamp?: Date;
}
interface Domain {
    id: string;
    name: string;
    verified: boolean;
    link: string;
    type: DomainTypeEnum;
    instanceId: string;
}
declare enum DeploymentStatusEnum {
    QUEUED = "Queued",
    PENDING = "Pending",
    DEPLOYED = "Deployed",
    FAILED = "Failed",
    DEPRECATED = "Deprecated",
    DEPRECATED_PROVIDER = "Deprecated-Provider"
}
declare enum DeploymentTypeEnum {
    DEPLOY = "DEPLOY",
    UPDATE = "UPDATE"
}
interface InstanceDeployment {
    id: string;
    type: DeploymentTypeEnum;
    status: DeploymentStatusEnum;
    buildTime: number;
    instance: string;
    connectionUrls: Array<string>;
    deploymentInitiator: string;
    instanceConfiguration: {
        image: string;
        tag: string;
        ports: Array<Port>;
        environmentVariables: Array<EnvironmentVariable>;
        secretEnvironmentVariables: Array<EnvironmentVariable>;
        commands: Array<string>;
        args: Array<string>;
        region: string;
        agreedMachine: MachineImageType;
    };
}
interface MachineImageType {
    machineName: string;
    agreementDate: number;
    cpu?: number;
    memory?: number;
    storage?: number;
    persistentStorage?: {
        size: number;
        class: PersistentStorageClassEnum;
        mountPoint: string;
    };
}
interface InstanceCreationConfig {
    configuration: {
        image: string;
        tag: string;
        ports: Array<Port>;
        environmentVariables?: Array<EnvironmentVariable>;
        secretEnvironmentVariables?: Array<EnvironmentVariable>;
        commands?: Array<string>;
        args?: Array<string>;
        region: string;
        machineImageId?: string;
        storage: number;
        persistentStorage?: {
            size: number;
            class: PersistentStorageClassEnum;
            mountPoint: string;
        };
        customSpecs?: {
            cpu: number;
            memory: number;
        };
        replicas: number;
    };
    clusterName: string;
    healthCheckConfig?: {
        path: string;
        port: number;
    };
    type: ComputeTypeEnum;
}
interface EnvironmentVariable {
    key: string;
    value: string;
}
interface MarketplaceInstanceCreationConfig {
    marketplaceAppId: string;
    environmentVariables: EnvironmentVariable[];
    machineImageId?: string;
    region: string;
    storage: number;
    type: ClusterProtocolEnum;
    customSpecs?: {
        cpu: number;
        memory: number;
    };
    persistentStorage?: {
        size: number;
        class: PersistentStorageClassEnum;
        mountPoint: string;
    };
    replicas: number;
}
interface InstanceResponse {
    clusterId: string;
    instanceId: string;
    instanceDeploymentId: string;
}
interface MarketplaceInstanceResponse extends InstanceResponse {
    marketplaceApp: MarketplaceApp;
    marketplaceAppId: string;
}
interface InstanceUpdateConfig {
    environmentVariables?: Array<EnvironmentVariable>;
    secretEnvironmentVariables?: Array<EnvironmentVariable>;
    commands?: Array<string>;
    args?: Array<string>;
    tag?: string;
    storage?: number;
    persistentStorage?: {
        size: number;
        class: PersistentStorageClassEnum;
        mountPoint: string;
    };
    customSpecs?: {
        cpu: number;
        memory: number;
    };
    instanceCount?: number;
}
interface UsageWithLimits {
    used: {
        computeCredit: number;
        computeBuildExecution: number;
        numberOfRequests: number;
        bandwidth: number;
        domains: number;
    };
    limit: {
        computeCredit: number;
        computeBuildExecution: number;
        bandwidth: number;
        domains: number;
    };
}
interface InstancesInfo {
    provisioned: number;
    provisioning: number;
    failedToProvision: number;
    closed: number;
    total: number;
}
declare enum DomainTypeEnum {
    DOMAIN = "domain",
    SUBDOMAIN = "subdomain"
}

declare class ClusterManager {
    private readonly spheronApi;
    constructor(spheronApi: SpheronApi);
    get(id: string): Promise<Cluster>;
    delete(id: string): Promise<void>;
    getInstancesInfo(id: string): Promise<InstancesInfo>;
    getUsage(id: string): Promise<ClusterFundsUsage>;
    getInstances(id: string, options: {
        skip: number;
        limit: number;
    }): Promise<InstanceDetailed[]>;
}

declare class ComputeMarketplaceManager {
    private readonly spheronApi;
    constructor(spheronApi: SpheronApi);
    getAll(): Promise<MarketplaceApp[]>;
    get(id: string): Promise<MarketplaceApp>;
    getCategories(): Promise<string[]>;
}

declare class Utils {
    private spheronApi;
    organizationId: string;
    constructor(spheronApi: SpheronApi);
    getOrganizationId(): Promise<string>;
}

declare class InstanceManager {
    private readonly spheronApi;
    private readonly utils;
    constructor(spheronApi: SpheronApi, utils: Utils);
    create(creationConfig: InstanceCreationConfig): Promise<InstanceResponse>;
    get(id: string): Promise<Instance>;
    delete(id: string): Promise<void>;
    update(id: string, updateConfig: InstanceUpdateConfig): Promise<InstanceResponse>;
    updateHealthCheck(id: string, healthCheckConfig: {
        path: string;
        port: number;
    }): Promise<{
        message: string;
        success: boolean;
    }>;
    close(id: string): Promise<{
        message: string;
        success: boolean;
    }>;
    getInstanceDeployment(id: string): Promise<InstanceDeployment>;
    getInstanceLogs(id: string, options: {
        from: number;
        to: number;
        logType: InstanceLogType;
        search?: string;
    }): Promise<Array<string>>;
    createFromMarketplace(createConfig: MarketplaceInstanceCreationConfig): Promise<MarketplaceInstanceResponse>;
    getDomains(id: string): Promise<Domain[]>;
    addDomain(instanceId: string, doamin: {
        link: string;
        type: DomainTypeEnum | string;
        name: string;
    }): Promise<Domain>;
    updateDomain(instanceId: string, domainId: string, doamin: {
        link: string;
        type: DomainTypeEnum | string;
        name: string;
    }): Promise<Domain>;
    deleteDomain(instanceId: string, domainId: string): Promise<void>;
    verifyDomain(instanceId: string, domainId: string): Promise<void>;
    getCdnDnsRecords(): Promise<{
        cdnARecords: string;
        cdnCnameRecords: string;
    }>;
    triggerLatestLog(instanceId: string): Promise<{
        message: string;
    }>;
    triggerLatestHealth(instanceId: string): Promise<{
        message: string;
    }>;
    private checkCreationConfig;
    private checkCustomSpecValues;
    private checkPersistentStorageValue;
}

declare class ComputeMachineManager {
    private readonly spheronApi;
    constructor(spheronApi: SpheronApi);
    get(options: {
        skip: number;
        limit: number;
        search?: string;
    }): Promise<ComputeMachine[]>;
    getRegions(): Promise<string[]>;
}

declare class OrganizationManager {
    private readonly spheronApi;
    private readonly utils;
    constructor(spheronApi: SpheronApi, utils: Utils);
    get(): Promise<Organization>;
    getClusters(options: {
        skip: number;
        limit: number;
    }): Promise<Cluster[]>;
    getUsage(): Promise<UsageWithLimits>;
}

interface SpheronClientConfiguration {
    token: string;
}
declare class SpheronClient {
    private readonly configuration;
    private readonly spheronApi;
    private readonly utils;
    readonly cluster: ClusterManager;
    readonly computeMarketplace: ComputeMarketplaceManager;
    readonly instance: InstanceManager;
    readonly computeMachine: ComputeMachineManager;
    readonly organization: OrganizationManager;
    constructor(configuration: SpheronClientConfiguration);
}

export { Cluster, ComputeMachine, DeploymentStatusEnum, DeploymentTypeEnum, Domain, DomainTypeEnum, EnvironmentVariable, Instance, InstanceCreationConfig, InstanceDeployment, InstanceDetailed, InstanceResponse, InstanceUpdateConfig, InstancesInfo, MarketplaceApp, MarketplaceAppVariable, MarketplaceInstanceCreationConfig, MarketplaceInstanceResponse, Organization, SpheronClient, SpheronClientConfiguration, UsageWithLimits, SpheronClient as default };
