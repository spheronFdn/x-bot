"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ClusterFundsUsage: () => import_core2.ClusterFundsUsage,
  ClusterProtocolEnum: () => import_core2.ClusterProtocolEnum,
  ClusterStateEnum: () => import_core2.ClusterStateEnum,
  DeploymentStatusEnum: () => DeploymentStatusEnum,
  DeploymentTypeEnum: () => DeploymentTypeEnum,
  DomainTypeEnum: () => DomainTypeEnum,
  InstanceLogType: () => import_core2.InstanceLogType,
  InstanceStateEnum: () => import_core2.InstanceStateEnum,
  MarketplaceAppPort: () => import_core2.MarketplaceAppPort,
  PersistentStorage: () => import_core2.PersistentStorage,
  PersistentStorageClassEnum: () => import_core2.PersistentStorageClassEnum,
  ProviderEnum: () => import_core2.ProviderEnum,
  SpheronClient: () => SpheronClient,
  UpdateInstaceRequest: () => import_core2.UpdateInstaceRequest,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/mappers.ts
var import_core = require("@spheron/core");

// ../../node_modules/uuid/dist/esm-node/rng.js
var import_crypto = __toESM(require("crypto"));
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// ../../node_modules/uuid/dist/esm-node/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// ../../node_modules/uuid/dist/esm-node/native.js
var import_crypto2 = __toESM(require("crypto"));
var native_default = {
  randomUUID: import_crypto2.default.randomUUID
};

// ../../node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/mappers.ts
var mapOrganization = (input) => {
  return {
    id: input._id,
    profile: {
      name: input.profile.name,
      username: input.profile.username,
      image: input.profile.image
    }
  };
};
var mapMarketplaceApp = (input) => {
  return {
    id: input._id,
    name: input.name,
    description: input.metadata.description,
    category: input.metadata.category,
    variables: input.serviceData.variables.map(
      (env) => {
        return {
          defaultValue: env.defaultValue,
          key: env.label,
          required: env.required
        };
      }
    )
  };
};
var mapComputeMachine = (input) => {
  return {
    id: input._id,
    name: input.name,
    cpu: input.cpu,
    storage: input.storage,
    memory: input.memory
  };
};
var mapCluster = (input) => {
  return {
    id: input._id,
    name: input.name,
    url: input.url,
    proivder: input.proivder,
    createdBy: input.createdBy,
    createdAt: input.createdAt,
    updatedAt: input.updatedAt
  };
};
var mapClusterInstance = (input) => {
  var _a, _b, _c, _d;
  return {
    id: input._id,
    state: input.state,
    name: input.name,
    deployments: input.orders,
    cluster: input.cluster,
    activeDeployment: input.activeOrder,
    agreedMachine: {
      machineName: input.agreedMachineImageType.machineType,
      agreementDate: input.agreedMachineImageType.agreementDate
    },
    healthCheck: input.healthCheck ? {
      path: (_a = input.healthCheck) == null ? void 0 : _a.url,
      port: (_b = input.healthCheck) == null ? void 0 : _b.port,
      status: (_c = input.healthCheck) == null ? void 0 : _c.status,
      timestamp: (_d = input.healthCheck) == null ? void 0 : _d.timestamp
    } : void 0,
    createdAt: input.createdAt,
    updatedAt: input.updatedAt
  };
};
var mapExtendedClusterInstance = (input) => {
  const baseClusterInstance = mapClusterInstance(input);
  return __spreadProps(__spreadValues({}, baseClusterInstance), {
    cpu: input.cpu,
    memory: input.memory,
    storage: input.storage,
    image: input.image,
    tag: input.tag
  });
};
var mapDomain = (coreDomain) => {
  return {
    id: coreDomain._id,
    name: coreDomain.name,
    verified: coreDomain.verified,
    link: coreDomain.link,
    type: coreDomain.type,
    instanceId: coreDomain.projectId
  };
};
var mapInstanceDeployment = (input) => {
  var _a, _b;
  const urlList = [];
  if (input.urlPrewiew && input.urlPrewiew !== "") {
    urlList.push(input.urlPrewiew);
  }
  if (((_a = input.protocolData) == null ? void 0 : _a.providerHost) && ((_b = input.protocolData) == null ? void 0 : _b.providerHost) != "") {
    input.clusterInstanceConfiguration.ports.forEach((port) => {
      urlList.push(`${input.protocolData.providerHost}:${port.exposedPort}`);
    });
  }
  const env = [];
  const secretEnv = [];
  input.clusterInstanceConfiguration.env.forEach((ev) => {
    if (ev.isSecret) {
      secretEnv.push({
        key: ev.value.split("=")[0],
        value: ev.value.split("=")[1]
      });
    } else {
      env.push({
        key: ev.value.split("=")[0],
        value: ev.value.split("=")[1]
      });
    }
  });
  return {
    id: input._id,
    type: input.type,
    status: input.status,
    buildTime: input.buildTime,
    instance: input.clusterInstance,
    instanceConfiguration: {
      image: input.clusterInstanceConfiguration.image,
      tag: input.clusterInstanceConfiguration.tag,
      ports: input.clusterInstanceConfiguration.ports,
      environmentVariables: env,
      secretEnvironmentVariables: secretEnv,
      commands: input.clusterInstanceConfiguration.command,
      args: input.clusterInstanceConfiguration.args,
      region: input.clusterInstanceConfiguration.region,
      agreedMachine: {
        machineName: input.clusterInstanceConfiguration.agreedMachineImage.machineType,
        agreementDate: input.clusterInstanceConfiguration.agreedMachineImage.agreementDate,
        cpu: input.clusterInstanceConfiguration.agreedMachineImage.cpu,
        memory: Number(
          input.clusterInstanceConfiguration.agreedMachineImage.memory.split(
            "Gi"
          )[0]
        ),
        storage: Number(
          input.clusterInstanceConfiguration.agreedMachineImage.storage.split(
            "Gi"
          )[0]
        ),
        persistentStorage: input.clusterInstanceConfiguration.agreedMachineImage.persistentStorage ? {
          size: Number(
            input.clusterInstanceConfiguration.agreedMachineImage.persistentStorage.size.split(
              "Gi"
            )[0]
          ),
          class: input.clusterInstanceConfiguration.agreedMachineImage.persistentStorage.class,
          mountPoint: input.clusterInstanceConfiguration.agreedMachineImage.persistentStorage.mountPoint
        } : void 0
      }
    },
    connectionUrls: urlList,
    deploymentInitiator: input.deploymentInitiator
  };
};
var mapCreateInstanceRequest = (input, organizationId, machineImageName) => {
  var _a, _b, _c, _d, _e, _f;
  return {
    organizationId,
    uniqueTopicId: v4_default(),
    configuration: {
      folderName: "",
      protocol: import_core.ClusterProtocolEnum.AKASH,
      image: input.configuration.image,
      tag: input.configuration.tag,
      instanceCount: input.configuration.replicas,
      buildImage: false,
      ports: input.configuration.ports,
      env: [
        ...input.configuration.environmentVariables ? mapVariables(input.configuration.environmentVariables, false) : [],
        ...input.configuration.secretEnvironmentVariables ? mapVariables(input.configuration.secretEnvironmentVariables, true) : []
      ],
      command: (_a = input.configuration.commands) != null ? _a : [],
      args: (_b = input.configuration.args) != null ? _b : [],
      region: input.configuration.region,
      akashMachineImageName: machineImageName != null ? machineImageName : "",
      customInstanceSpecs: {
        storage: `${input.configuration.storage}Gi`,
        persistentStorage: input.configuration.persistentStorage && {
          size: `${input.configuration.persistentStorage.size}Gi`,
          class: input.configuration.persistentStorage.class,
          mountPoint: input.configuration.persistentStorage.mountPoint
        },
        cpu: (_c = input.configuration.customSpecs) == null ? void 0 : _c.cpu,
        memory: ((_d = input.configuration.customSpecs) == null ? void 0 : _d.memory) ? `${input.configuration.customSpecs.memory}Gi` : void 0
      }
    },
    clusterUrl: input.configuration.image,
    clusterProvider: import_core.ProviderEnum.DOCKERHUB,
    clusterName: input.clusterName,
    healthCheckUrl: (_e = input == null ? void 0 : input.healthCheckConfig) == null ? void 0 : _e.path,
    healthCheckPort: (_f = input == null ? void 0 : input.healthCheckConfig) == null ? void 0 : _f.port,
    scalable: input.type === import_core.ComputeTypeEnum.DEMAND
  };
};
var mapMarketplaceInstanceCreationConfig = (input, organizationId) => {
  var _a, _b, _c;
  return {
    templateId: input.marketplaceAppId,
    environmentVariables: input.environmentVariables.map(
      (env) => {
        return {
          label: env.key,
          value: env.value
        };
      }
    ),
    organizationId,
    akashImageId: (_a = input.machineImageId) != null ? _a : "",
    uniqueTopicId: v4_default(),
    region: input.region,
    instanceCount: input.replicas,
    customInstanceSpecs: {
      storage: `${input.storage}Gi`,
      persistentStorage: input.persistentStorage && {
        size: `${input.persistentStorage.size}Gi`,
        class: input.persistentStorage.class,
        mountPoint: input.persistentStorage.mountPoint
      },
      cpu: (_b = input.customSpecs) == null ? void 0 : _b.cpu,
      memory: ((_c = input.customSpecs) == null ? void 0 : _c.memory) ? `${input.customSpecs.memory}Gi` : void 0
    }
  };
};
var mapInstanceResponse = (input) => {
  return {
    clusterId: input.clusterId,
    instanceId: input.clusterInstanceId,
    instanceDeploymentId: input.clusterInstanceOrderId
  };
};
var mapMarketplaceInstanceResponse = (input) => {
  const baseInstanceResponse = mapInstanceResponse(input);
  return __spreadProps(__spreadValues({}, baseInstanceResponse), {
    marketplaceApp: mapMarketplaceApp(input.template),
    marketplaceAppId: input.templateId
  });
};
var mapInstanceUpdateRequest = (input, existingConfig) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  return {
    env: [
      ...input.environmentVariables ? mapVariables(input.environmentVariables, false) : mapVariables(existingConfig.environmentVariables, false),
      ...input.secretEnvironmentVariables ? mapVariables(input.secretEnvironmentVariables, true) : mapVariables(existingConfig.secretEnvironmentVariables, true)
    ],
    command: (_a = input.commands) != null ? _a : existingConfig.commands,
    args: (_b = input.args) != null ? _b : existingConfig.args,
    uniqueTopicId: v4_default(),
    tag: (_c = input.tag) != null ? _c : existingConfig.tag,
    customInstanceSpecs: {
      storage: (_d = `${input.storage}Gi`) != null ? _d : existingConfig.storage,
      persistentStorage: input.persistentStorage && {
        size: `${input.persistentStorage.size}Gi`,
        class: input.persistentStorage.class,
        mountPoint: input.persistentStorage.mountPoint
      },
      cpu: (_g = (_e = input.customSpecs) == null ? void 0 : _e.cpu) != null ? _g : (_f = existingConfig.customSpecs) == null ? void 0 : _f.cpu,
      memory: ((_h = input.customSpecs) == null ? void 0 : _h.memory) ? `${input.customSpecs.memory}Gi` : ((_i = existingConfig.customSpecs) == null ? void 0 : _i.memory) || void 0
    },
    instanceCount: (_j = input.instanceCount) != null ? _j : existingConfig.instanceCount
  };
};
var mapUsageWithLimits = (usage, tokenPrice) => {
  return {
    used: {
      computeCredit: usage.usedClusterAkt / 1e6 * tokenPrice,
      computeBuildExecution: usage.usedClusterBuildExecution,
      numberOfRequests: usage.usedNumberOfRequests,
      bandwidth: usage.usedBandwidth,
      domains: usage.usedDomains
    },
    limit: {
      computeCredit: usage.clusterAktLimit / 1e6 * tokenPrice,
      computeBuildExecution: usage.clusterBuildExecutionLimit,
      bandwidth: usage.bandwidthLimit,
      domains: usage.domainsLimit
    }
  };
};
var mapInstancesInfo = (input) => {
  return {
    provisioned: input.active,
    provisioning: input.starting,
    failedToProvision: input.failedToStart,
    closed: input.closed,
    total: input.total
  };
};
var mapVariables = (variables, isSecret) => {
  return variables.map((ev) => ({
    value: `${ev.key}=${ev.value}`,
    isSecret
  }));
};

// src/cluster-manager.ts
var ClusterManager = class {
  constructor(spheronApi) {
    this.spheronApi = spheronApi;
  }
  get(id) {
    return __async(this, null, function* () {
      const cluster = yield this.spheronApi.getCluster(id);
      return mapCluster(cluster);
    });
  }
  delete(id) {
    return __async(this, null, function* () {
      yield this.spheronApi.deleteCluster(id);
    });
  }
  getInstancesInfo(id) {
    return __async(this, null, function* () {
      const response = yield this.spheronApi.getClusterInstancesDetails(id);
      return mapInstancesInfo(response);
    });
  }
  getUsage(id) {
    return __async(this, null, function* () {
      const response = yield this.spheronApi.getClusterFundsUsage(id);
      const pricePerToken = yield this.spheronApi.getPriceForToken(7431);
      return {
        dailyUsage: response.dailyUsage / 1e6 * pricePerToken,
        usedTillNow: response.usedTillNow / 1e6 * pricePerToken
      };
    });
  }
  getInstances(id, options) {
    return __async(this, null, function* () {
      if (options.skip < 0 || options.limit < 0) {
        throw new Error(`Skip and Limit cannot be negative numbers.`);
      }
      const clusterInstances = yield this.spheronApi.getClusterInstances(
        id,
        options
      );
      return clusterInstances.map((x) => mapExtendedClusterInstance(x));
    });
  }
};

// src/compute-marketplace-manager.ts
var ComputeMarketplaceManager = class {
  constructor(spheronApi) {
    this.spheronApi = spheronApi;
  }
  getAll() {
    return __async(this, null, function* () {
      const marketplaceApps = yield this.spheronApi.getClusterTemplates();
      return marketplaceApps.map((x) => mapMarketplaceApp(x));
    });
  }
  get(id) {
    return __async(this, null, function* () {
      const marketplaceApp = yield this.spheronApi.getClusterTemplate(id);
      return mapMarketplaceApp(marketplaceApp);
    });
  }
  getCategories() {
    return __async(this, null, function* () {
      return this.spheronApi.getClusterCategories();
    });
  }
};

// src/instance-manager.ts
var InstanceManager = class {
  constructor(spheronApi, utils) {
    this.spheronApi = spheronApi;
    this.utils = utils;
  }
  create(creationConfig) {
    return __async(this, null, function* () {
      this.checkCreationConfig(creationConfig.configuration);
      const organizationId = yield this.utils.getOrganizationId();
      let machineName;
      if (creationConfig.configuration.machineImageId) {
        const computeMachines = yield this.spheronApi.getComputeMachines({
          skip: 0,
          limit: 10
        });
        const computeMachine = computeMachines.find(
          (m) => m._id === creationConfig.configuration.machineImageId
        );
        if (!computeMachine) {
          throw new Error(
            `Compute machine with id ${creationConfig.configuration.machineImageId} not found!`
          );
        }
        machineName = computeMachine.name;
      }
      const response = yield this.spheronApi.createClusterInstance(
        mapCreateInstanceRequest(creationConfig, organizationId, machineName)
      );
      return mapInstanceResponse(response);
    });
  }
  get(id) {
    return __async(this, null, function* () {
      const clusterInstance = yield this.spheronApi.getClusterInstance(id);
      return mapClusterInstance(clusterInstance);
    });
  }
  delete(id) {
    return __async(this, null, function* () {
      return this.spheronApi.deleteClusterInstance(id);
    });
  }
  update(id, updateConfig) {
    return __async(this, null, function* () {
      const organizationId = yield this.utils.getOrganizationId();
      if (!updateConfig.args && !updateConfig.commands && !updateConfig.environmentVariables && !updateConfig.secretEnvironmentVariables && !updateConfig.tag && !updateConfig.storage && !updateConfig.persistentStorage && !updateConfig.customSpecs && !updateConfig.instanceCount) {
        throw new Error(`Nothing to update.`);
      }
      const instance = yield this.get(id);
      if (!instance.activeDeployment) {
        throw new Error(`Instance ${id} doesnt have active deployments.`);
      }
      const deployment = yield this.getInstanceDeployment(
        instance.activeDeployment
      );
      const response = yield this.spheronApi.updateClusterInstance(
        id,
        organizationId,
        mapInstanceUpdateRequest(updateConfig, deployment.instanceConfiguration)
      );
      return mapInstanceResponse(response);
    });
  }
  updateHealthCheck(id, healthCheckConfig) {
    return __async(this, null, function* () {
      const response = yield this.spheronApi.updateClusterInstanceHealthCheckInfo(
        id,
        {
          path: healthCheckConfig.path,
          cointainerPort: healthCheckConfig.port
        }
      );
      return { message: response.message, success: response.updated };
    });
  }
  close(id) {
    return __async(this, null, function* () {
      return this.spheronApi.closeClusterInstance(id);
    });
  }
  getInstanceDeployment(id) {
    return __async(this, null, function* () {
      const clusterInstanceOrder = yield this.spheronApi.getClusterInstanceOrder(
        id
      );
      return mapInstanceDeployment(clusterInstanceOrder.order);
    });
  }
  getInstanceLogs(id, options) {
    return __async(this, null, function* () {
      if (options.from < 0 || options.to < 0) {
        throw new Error(`From and To cannot be negative numbers.`);
      }
      const logsResponse = yield this.spheronApi.getClusterInstanceOrderLogs(
        id,
        options
      );
      return logsResponse.logs;
    });
  }
  createFromMarketplace(createConfig) {
    return __async(this, null, function* () {
      this.checkCreationConfig(createConfig);
      const organizationId = yield this.utils.getOrganizationId();
      const response = yield this.spheronApi.createClusterInstanceFromTemplate(
        mapMarketplaceInstanceCreationConfig(createConfig, organizationId)
      );
      return mapMarketplaceInstanceResponse(response);
    });
  }
  getDomains(id) {
    return __async(this, null, function* () {
      const domains = yield this.spheronApi.getClusterInstanceDomains(id);
      return domains.map((x) => mapDomain(x));
    });
  }
  addDomain(instanceId, doamin) {
    return __async(this, null, function* () {
      const domain = yield this.spheronApi.addClusterInstanceDomain(instanceId, {
        link: doamin.link,
        type: doamin.type,
        name: doamin.name
      });
      return mapDomain(domain);
    });
  }
  updateDomain(instanceId, domainId, doamin) {
    return __async(this, null, function* () {
      const domain = yield this.spheronApi.updateClusterInstanceDomain(
        instanceId,
        domainId,
        {
          link: doamin.link,
          type: doamin.type,
          name: doamin.name
        }
      );
      return mapDomain(domain);
    });
  }
  deleteDomain(instanceId, domainId) {
    return __async(this, null, function* () {
      return this.spheronApi.deleteClusterInstanceDomain(instanceId, domainId);
    });
  }
  verifyDomain(instanceId, domainId) {
    return __async(this, null, function* () {
      return this.spheronApi.verifyClusterInstanceDomain(instanceId, domainId);
    });
  }
  getCdnDnsRecords() {
    return __async(this, null, function* () {
      const { recordIpv4V2, recordCnameV2 } = yield this.spheronApi.getCdnRecords();
      return {
        cdnARecords: recordIpv4V2,
        cdnCnameRecords: recordCnameV2
      };
    });
  }
  triggerLatestLog(instanceId) {
    return __async(this, null, function* () {
      return this.spheronApi.triggerClusterInstanceLogFetch(instanceId, v4_default());
    });
  }
  triggerLatestHealth(instanceId) {
    return __async(this, null, function* () {
      return this.spheronApi.triggerClusterInstanceHealthCheck(
        instanceId,
        v4_default()
      );
    });
  }
  checkCreationConfig(configuration) {
    if (configuration.machineImageId && configuration.customSpecs) {
      throw new Error(
        `Custom specification cannot be applied when machine image is specified!`
      );
    }
    if (configuration.replicas < 1) {
      throw new Error(`Replication factor cannot be less than 1!`);
    }
    this.checkCustomSpecValues(configuration.customSpecs);
    this.checkPersistentStorageValue(configuration.persistentStorage);
    if (configuration.storage > 1024 || configuration.storage < 1) {
      throw new Error(`Instance storage must be number between 1 and 1024!`);
    }
  }
  checkCustomSpecValues(customSpecs) {
    if (!customSpecs) {
      return;
    }
    const validValues = [0.5, 1, 2, 4, 8, 16, 32];
    if (!validValues.includes(customSpecs.cpu)) {
      throw new Error(
        `Cpu must have one of following values: ${JSON.stringify(validValues)}!`
      );
    }
    if (!validValues.includes(customSpecs.memory)) {
      throw new Error(
        `Memory must have one of following values: ${JSON.stringify(
          validValues
        )}!`
      );
    }
  }
  checkPersistentStorageValue(persistentStorage) {
    if (persistentStorage && (persistentStorage.size > 1024 || persistentStorage.size < 1)) {
      throw new Error(`Persistent storage must be number between 1 and 1024!`);
    }
  }
};

// src/cluter-machine-manager.ts
var ComputeMachineManager = class {
  constructor(spheronApi) {
    this.spheronApi = spheronApi;
  }
  get(options) {
    return __async(this, null, function* () {
      if (options.limit < 1 || options.skip < 0) {
        throw new Error(
          `Limit and Skip cannot be negative numbers. Limit must be greater thatn 1.`
        );
      }
      const computeMachines = yield this.spheronApi.getComputeMachines(options);
      return computeMachines.map((x) => mapComputeMachine(x));
    });
  }
  getRegions() {
    return __async(this, null, function* () {
      return this.spheronApi.getComputeMachineRegions();
    });
  }
};

// src/organization-manager.ts
var OrganizationManager = class {
  constructor(spheronApi, utils) {
    this.spheronApi = spheronApi;
    this.utils = utils;
  }
  get() {
    return __async(this, null, function* () {
      const organizationId = yield this.utils.getOrganizationId();
      const organization = yield this.spheronApi.getOrganization(organizationId);
      return mapOrganization(organization);
    });
  }
  getClusters(options) {
    return __async(this, null, function* () {
      const organizationId = yield this.utils.getOrganizationId();
      const clusters = yield this.spheronApi.getOrganizationClusters(
        organizationId,
        options
      );
      return clusters.map((x) => mapCluster(x));
    });
  }
  getUsage() {
    return __async(this, null, function* () {
      const organizationId = yield this.utils.getOrganizationId();
      const usage = yield this.spheronApi.getOrganizationUsage(
        organizationId,
        "c-akash"
      );
      const pricePerToken = yield this.spheronApi.getPriceForToken(7431);
      const _a = usage, { usedStorageSkynet, storageSkynetLimit } = _a, resultWithoutSkynet = __objRest(_a, ["usedStorageSkynet", "storageSkynetLimit"]);
      return mapUsageWithLimits(resultWithoutSkynet, pricePerToken);
    });
  }
};
var organization_manager_default = OrganizationManager;

// src/index.ts
var import_core3 = require("@spheron/core");

// src/utils.ts
var Utils = class {
  constructor(spheronApi) {
    this.organizationId = "";
    this.spheronApi = spheronApi;
    this.organizationId = "";
  }
  getOrganizationId() {
    return __async(this, null, function* () {
      if (!this.organizationId || this.organizationId === "") {
        const tokenScope = yield this.spheronApi.getTokenScope();
        if (tokenScope.organizations.length != 1) {
          throw new Error(`Unsuported token! Please use single scope token.`);
        }
        this.organizationId = tokenScope.organizations[0].id;
      }
      return this.organizationId;
    });
  }
};
var utils_default = Utils;

// src/interfaces.ts
var import_core2 = require("@spheron/core");
var DeploymentStatusEnum = /* @__PURE__ */ ((DeploymentStatusEnum2) => {
  DeploymentStatusEnum2["QUEUED"] = "Queued";
  DeploymentStatusEnum2["PENDING"] = "Pending";
  DeploymentStatusEnum2["DEPLOYED"] = "Deployed";
  DeploymentStatusEnum2["FAILED"] = "Failed";
  DeploymentStatusEnum2["DEPRECATED"] = "Deprecated";
  DeploymentStatusEnum2["DEPRECATED_PROVIDER"] = "Deprecated-Provider";
  return DeploymentStatusEnum2;
})(DeploymentStatusEnum || {});
var DeploymentTypeEnum = /* @__PURE__ */ ((DeploymentTypeEnum2) => {
  DeploymentTypeEnum2["DEPLOY"] = "DEPLOY";
  DeploymentTypeEnum2["UPDATE"] = "UPDATE";
  return DeploymentTypeEnum2;
})(DeploymentTypeEnum || {});
var DomainTypeEnum = /* @__PURE__ */ ((DomainTypeEnum2) => {
  DomainTypeEnum2["DOMAIN"] = "domain";
  DomainTypeEnum2["SUBDOMAIN"] = "subdomain";
  return DomainTypeEnum2;
})(DomainTypeEnum || {});

// src/index.ts
var SpheronClient = class {
  constructor(configuration) {
    this.configuration = configuration;
    this.spheronApi = new import_core3.SpheronApi(this.configuration.token);
    this.utils = new utils_default(this.spheronApi);
    this.cluster = new ClusterManager(this.spheronApi);
    this.computeMarketplace = new ComputeMarketplaceManager(this.spheronApi);
    this.instance = new InstanceManager(this.spheronApi, this.utils);
    this.computeMachine = new ComputeMachineManager(this.spheronApi);
    this.organization = new organization_manager_default(this.spheronApi, this.utils);
  }
};
var src_default = SpheronClient;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ClusterFundsUsage,
  ClusterProtocolEnum,
  ClusterStateEnum,
  DeploymentStatusEnum,
  DeploymentTypeEnum,
  DomainTypeEnum,
  InstanceLogType,
  InstanceStateEnum,
  MarketplaceAppPort,
  PersistentStorage,
  PersistentStorageClassEnum,
  ProviderEnum,
  SpheronClient,
  UpdateInstaceRequest
});
